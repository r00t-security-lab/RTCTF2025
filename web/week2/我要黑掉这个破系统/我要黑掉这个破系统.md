# 我要黑掉这个破系统！！！

虽然这道题是作为半个防ak题上的，但是其实我给大家留了一个小后门，可惜没人发现，导致这题的二阶段没有解锁

## 一阶段

一阶段是不需要附件的，所以没有附件。

首先我们先注册一个账户，登录之后发现有一个很明显的admin，但是没有权限访问![image-20251208200916006](我要黑掉这个破系统/image-20251208200916006.png)

view details貌似也没有什么有用的功能

![image-20251208200949455](我要黑掉这个破系统/image-20251208200949455.png)

当你测试搜索功能的时候就很容易发现

![image-20251208201014181](我要黑掉这个破系统/image-20251208201014181.png)

观察url http://118.89.197.242:33389/employees?query=1

遇到这种查询的方式就很有可能会有sql注入，所以我们测试一下，利用order by探测一下表结构（预热赛的时候讲过，打法一模一样）

![image-20251208201414493](我要黑掉这个破系统/image-20251208201414493.png)

![image-20251208201427003](我要黑掉这个破系统/image-20251208201427003.png)

可以看到有四列，按照兴趣小组的时候讲的方法，可以获取完整的表的内容，这里就不赘述了

这里是一个users表，字段为id, username,is_admin, password_hash，如果我们能查出admin的密码是不是就可以登录了

payload如下：

```
' UNION SELECT id, username,is_admin,password_hash FROM users -- 
```

相信兴趣小组认真听讲的同学都可以看懂这个payload

![image-20251208201818425](我要黑掉这个破系统/image-20251208201818425.png)

可以看到每个账户的密码都是存的hash值，并且不仅有一个admin账户，还有一个admin1账户。到这里大家可能不知道怎么办了，如果密码是弱密码的话，hash是可以爆出来的，可以尝试爆破这两个admin的hash，使用hashcat，密码本用kali自带的rockyou（其实我的弱密码就是从rockyou里面选的，所以很快就能爆出来），~~没爆一下试试的可以拍断大腿了~~

没用过hashcat的同学可以看一下这篇文章   [hashcat 暴力破解详细教程 (附常见案例) | lololowe 的博客](https://blog.lololowe.com/posts/f502/#3-hashcat-使用)

这里admin用的是强密码，admin1用的是弱密码，所以可以用admin1的账号登录

然后访问/admin就能拿到flag



## 二阶段

二阶段没放出来，感兴趣的同学可以看一下

删除了admin1的账号，这个时候admin的密码又爆不出来，怎么办呢，可以看下这题的附件（虽然没放出来）

app.py

```python
import os
import secrets
import sqlite3
import time
from functools import wraps

import bcrypt
import jwt
from dotenv import load_dotenv
from flask import (
    Flask,
    flash,
    jsonify,
    make_response,
    redirect,
    render_template,
    request,
)

app = Flask(__name__)
app.static_folder = "static"
load_dotenv()
app.config["SECRET_KEY"] = "".join(
    [secrets.choice("abcdef0123456789") for _ in range(32)]
)
FLAG = os.getenv("GZCTF_FLAG")


def init_db():
    conn = sqlite3.connect("database.db")
    cursor = conn.cursor()
    cursor.execute("""DROP TABLE IF EXISTS employees;""")
    cursor.execute("""DROP TABLE IF EXISTS revoked_tokens;""")
    cursor.execute("""DROP TABLE IF EXISTS users;""")
    cursor.execute("""CREATE TABLE IF NOT EXISTS users (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        username TEXT UNIQUE NOT NULL,
                        is_admin BOOL NOT NULL,
                        password_hash TEXT NOT NULL)""")
    cursor.execute("""CREATE TABLE IF NOT EXISTS revoked_tokens (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        token TEXT NOT NULL)""")
    cursor.execute("""CREATE TABLE IF NOT EXISTS employees (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        name TEXT NOT NULL,
                        email TEXT UNIQUE NOT NULL,
                        position TEXT NOT NULL,
                        phone TEXT NOT NULL,
                        location TEXT NOT NULL)""")
    conn.commit()
    conn.close()


def get_db_connection():
    conn = sqlite3.connect("database.db")
    conn.row_factory = sqlite3.Row
    return conn


def token_required(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        token = request.cookies.get("JWT")
        if not token:
            flash("Token is missing!", "error")
            return redirect("/login")

        try:
            data = jwt.decode(token, app.config["SECRET_KEY"], algorithms=["HS256"])
            username = data["username"]

            conn = get_db_connection()
            user = conn.execute(
                "SELECT id,is_admin FROM users WHERE username = ?", (username,)
            ).fetchone()
            revoked = conn.execute(
                "SELECT id FROM revoked_tokens WHERE token = ?", (token,)
            ).fetchone()
            conn.close()

            if not user or revoked:
                flash("Invalid or revoked token!", "error")
                return redirect("/login")

            request.is_admin = user["is_admin"]
            request.username = username

        except jwt.InvalidTokenError:
            flash("Invalid token!", "error")
            return redirect("/login")

        return f(*args, **kwargs)

    return decorated


@app.route("/", methods=["GET"])
def index():
    token = request.cookies.get("JWT", None)
    if token is None:
        return redirect("/login")
    else:
        return redirect("/employees")


@app.route("/register", methods=["GET", "POST"])
def register():
    if request.method == "GET":
        return render_template("register.html")
    elif request.method == "POST":
        data = request.form
        username = data.get("username")
        password = data.get("password")

        if not username or not password:
            return jsonify({"message": "Username and password required!"}), 400

        password_hash = bcrypt.hashpw(
            password.encode("utf-8"), bcrypt.gensalt()
        ).decode("utf-8")

        conn = get_db_connection()
        try:
            conn.execute(
                "INSERT INTO users (username, is_admin, password_hash) VALUES (?, ?, ?)",
                (username, False, password_hash),
            )
            conn.commit()
        except sqlite3.IntegrityError:
            flash("User already exists.", "error")
            return redirect("/register")
        finally:
            conn.close()

        flash("User created successfully.", "success")
        return redirect("/login")


@app.route("/login", methods=["GET", "POST"])
def login():
    if request.method == "GET":
        return render_template("login.html")
    elif request.method == "POST":
        data = request.form
        username = data.get("username")
        password = data.get("password")

        conn = get_db_connection()
        user = conn.execute(
            "SELECT * FROM users WHERE username = ?", (username,)
        ).fetchone()
        conn.close()

        if user and bcrypt.checkpw(
            password.encode("utf-8"), user["password_hash"].encode("utf-8")
        ):
            token = jwt.encode(
                {
                    "username": username,
                    "is_admin": user["is_admin"],
                    "issued": time.time(),
                },
                app.config["SECRET_KEY"],
                algorithm="HS256",
            )
            resp = make_response(redirect("/employees"))
            resp.set_cookie("JWT", token)
            return resp

        flash("Invalid credentials.", "error")
        return redirect("/login")


@app.route("/logout", methods=["GET"])
def logout():
    token = request.cookies.get("JWT")
    if token:
        conn = get_db_connection()
        conn.execute("INSERT INTO revoked_tokens (token) VALUES (?)", (token,))
        conn.commit()
        conn.close()
    resp = make_response(redirect("/login"))
    resp.delete_cookie("JWT")
    return resp


@app.route("/employees", methods=["GET"])
@token_required
def employees():
    query = request.args.get("query", "")
    conn = get_db_connection()
    cursor = conn.cursor()
    cursor.execute(
        f"SELECT id, name, email, position FROM employees WHERE name LIKE '%{query}%'"
    )
    results = cursor.fetchall()
    conn.close()
    print(request.username)
    return render_template("employees.html", username=request.username, employees=results, query=query)


@app.route("/employee/<int:employee_id>", methods=["GET"])
@token_required
def employee_details(employee_id):
    conn = get_db_connection()
    employee = conn.execute(
        "SELECT * FROM employees WHERE id = ?", (employee_id,)
    ).fetchone()
    conn.close()
    print(employee)
    if not employee:
        flash("Employee not found", "error")
        return redirect("/employees")
    return render_template("employee_details.html", username=request.username, employee=employee)


@app.route("/admin", methods=["GET"])
@token_required
def admin():
    is_admin = getattr(request, "is_admin", None)
    if is_admin:
        return render_template("admin.html", username=request.username, flag=FLAG)

    flash("You don't have the permission to access this area", "error")
    return redirect("/employees")


if __name__ == "__main__":
    # init_db()
    
    # Generate and insert admin token into revoked_tokens on startup
    # This ensures the token is valid for the current session's random secret key
    with app.app_context():
        conn = get_db_connection()
        token = jwt.encode(
            {
                "username": "admin",
                "is_admin": True,
                "issued": time.time(),
            },
            app.config["SECRET_KEY"],
            algorithm="HS256",
        )
        conn.execute("INSERT INTO revoked_tokens (token) VALUES (?)", (token,))
        conn.commit()
        conn.close()
        print(f"Admin token added to revoked_tokens: {token}")

    app.run(debug=False, host="0.0.0.0", port=5000)

```

不难注意到有一个revoked_tokens表，在用户退出的时候，会把他的token存到这个表里面，那么admin曾经用过的token肯定也在里面了，如果我们能拿到admin的token，是不是就可以以admin的身份登录，去访问/admin，拿到flag了，想拿到也很简单，因为一阶段的时候我们已经sql注入把数据库都读出来了，你在探测的时候肯定也注意到这个表了，所以很容易读到admin的token

![image-20251208205538806](我要黑掉这个破系统/image-20251208205538806.png)

但是你读到了也用不了，为什么呢，不难注意到下面这行代码

```python
     revoked = conn.execute(
                "SELECT id FROM revoked_tokens WHERE token = ?", (token,)
            ).fetchone()     
    if not user or revoked:
                flash("Invalid or revoked token!", "error")
                return redirect("/login")
```

也就是他会检查一下我们的token是不是在revoked_tokens表里的，如果在，就无法登录成功，难道我们好不容易到手的token就用不了了吗？

但是目测也没有其他地方有漏洞了，所以这里肯定是突破口

数据库查询的方式要求你用的token和他存的token完全一样才会被拦截，那么我们这个时候给这个token后面加一个“=”就可以了，后面会解释为什么

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwiaXNfYWRtaW4iOnRydWUsImlzc3VlZCI6MTc2NTE5NTUyMy43NDg5MDV9.H0Sl6-s-UO8YKrNZzG3Xet4vx_f19V8l6dIyAHYvskE=
```

![image-20251208205626247](我要黑掉这个破系统/image-20251208205626247.png)

可以看到，当我们替换token之后，右上角的用户名已经变成admin了，访问/admin

![image-20251208205704028](我要黑掉这个破系统/image-20251208205704028.png)

**原因**：如果你去看jwt的原理你就会发现，其实他用了base64，即使是不深入去看他的源码也不难想到可以尝试在末尾加一个=看看能不能执行成功，显然我们成功了，而因为有了这个等号，他就不会在数据库查到，也就不会被拦截。