## XorGift

### 题目描述

仙人Xor观汝无能分解大数，特此降下此礼。不过，其中艰险还得汝从微末逐步恢复才能知其全貌。

### 解题思路

简单来说刨去RSA的简单环节，就是我们需要用p*q, p^q两个值恢复p和q两个值。

这种形式长得很像我们之前学的韦达（又是他），但是操作起来却完全不同。

由于我们知道其实异或操作是基于位来实现的，那么我们进行恢复p和q也应该从位的角度去思考。

我们先考虑`0*1=0, 1*1=1`；再考虑`00*01=00, 00*10=00, 0001*01=1, 10*01=10, 11*01=11, 10*10=100, 11*10=110, 11*11=1001`（以上均为2进制）

我们可以看到，在从最低位恢复起来的时候，先用异或符合要求，再和相同位数的乘积进行比较，每次都可以去除大约一半的可能性，进行二分，从而可以在很短的时间内完成解题。

最后解出p和q之后就是最基础的RSA，不过多赘述了。

那么编写脚本如下：

```python
import sys
sys.setrecursionlimit(1400)

n = 16702674774528873939540458884046577414568845527421323339037007994611132323830210598914035413462951852791156063220094547270688444274645267863686142854887925744404568689051498650617266485966886344452767868990307836338468779936483127054958681653442512621688575215981296226761196833683085174112499766072078184745252062137559404703815577037792049155645906056026972503489115165144960780067627363862829219473630206747924755700844420547344434490251908566488309813939188799045917692125319404030299472715330266676887082496703575542803877037978947571969635417747950214102094075156220190603452152445034801257306010449534313134017
gift = 85136879237299840751284303655620244911388102377660334443013707688101996041562973947398908983370126470360855028189514410383765756018632862309308251137610286828673303654456344433214580689315507684891620633729206270299019055217266989566833152185056529976637707254388397700073020044707356205721056870125586546408
c = 10553596658402415364329618269175095373188983383625830641679584430616777252957235806793965065283040204609859100020886431371450346209748454387275236807579861055880883523175121036791803635156090340246910035947995701850957831495119199106405201894184062311961502039018514007827972674710331453619594993496558503611128833053864195415754443677088282343561363667566133980414515179892113357702415198348615930208912589869708579623549405352838643120096990376236247070612288693415227402694670197964412204939322678427932386570204286366899010262726210042177037012173605648575270452572741807790623532003295164747054397547208246177974
len = gift.bit_length()

p_n =0
q_n =0

def cycle(p:int,q:int,bit_len:int):
    # print(f'{bit_len=}')
    if bit_len == 1024:
        if (p^q == gift) and (p*q == n):
            global p_n, q_n
            p_n = p
            q_n = q
            
        return
    bit = (gift & (1 << bit_len)) >> bit_len
    for p_0 in (1,0):
        q_0 = p_0^bit
        # print(f'{bin(p_0)=}\n{bin(q_0)=}')
        assert(p.bit_length()<=bit_len)
        temp = (p|(p_0<<bit_len))*(q|(q_0<<bit_len))
        if temp&((1<<bit_len)-1) == n&((1<<bit_len)-1):
            p_new = p|(p_0<<bit_len)
            q_new = q|(q_0<<bit_len)
            cycle(p_new,q_new,bit_len+1)

cycle(0,0,0)

from Crypto.Util.number import *
p = p_n
q = q_n
e = 0x10001
d = inverse(e, (p-1)*(q-1))
m = pow(c,d,n)
print(long_to_bytes(m))

```

### 出题思路

希望大家可以养成从比特位来思考的习惯，毕竟现代中密码学大多和计算机相关，而计算机又是基于二进制的，和比特相关。