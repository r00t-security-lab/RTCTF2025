## Q的邻居

### 题目描述

Q先生有个好邻居P先生，虽然他们的家相隔114514条街道，但是P先生总会在Q先生需要帮助的时候出现。 难道P先生是指Peter Porker？

### 解题思路

我们知道p的选取方法是进行了114514次`nextprime(Q)`，那么两者其实隔的还挺近的，如果不信我们可以验证一下：
$$
以π(x)表示不超过x的素数的个数，其中π(x)渐近于\frac{x}{ln(x)}。\\
那么我们已知q = getPrime(512)，是较大的一个素数。\\
其和114514次后的差大概可以通过\\
\frac{(a+2^{512})}{ln(a+2^{512})}-\frac{(2^{512})}{ln(2^{512})}=114514求解出的a的上限估算大小。\\
$$
用高数方法稍微导一下，估算出来a的大小最大大约是4075万，这相比512bit的数可谓是非常之小了。

当然，这个大小如果直接开根从中间开始尝试的话的确比较慢，需要遍历
$$
\sqrt{pq}-p或者q-\sqrt{pq}个数 \\
即大约\sqrt{p^2+4.075*10^{7}p}-p, p=getprime(512), 两千万左右。\\
$$
但是我们为什么要直接求出p和q呢？相比之下，算数平均数`(p+q)/2`明显更加接近，而且与`根号n`这个几何平均数的比较我们很早就学过了。

所以如果我们这么操作：
$$
从\sqrt{pq}遍历到\frac{p+q}{2}\\
需\frac{p+q}{2}-\sqrt{pq}个数(其中p,q=getPrime(512),p-q=4.075*10^{7})，\\
太小了，我似乎算错了，怎么算出来数量级大概才10^{−140}？\\
有兴趣可以看下哪里估算误差太大了。\\
反正很小就是了。
 
$$
于是我们可以从费马分解的角度考虑：
$$
\frac{(p+q)^2}{4}-n=\frac{(p+q)^2}{4}-pq=\frac{(p-q)^2}{4}
$$
从几何平均数开始向上遍历，如果那个数的平方与n的差值是完全平方数的话，则遍历到的数就是算数平均数，得到的完全平方数开方后则是算数平均数减去pq中小的那个。

所以，脚本如下：

```python
from Crypto.Util.number import *
import math
from tqdm import tqdm


n = 47278820623254084470712991726964332629936212131100164534868302802445084394886707670928058558387515635324218539239337944151605762422167386203142147717118140995760722770459205025883531651944612603216728887212810088277817818123961289700423618777779205343970683576736608307649361262320306442092060936523925584503
c = 7105189801173778706396894181479836936961959392591875714507187755559435361102824545637041236323183792217515615781431392469097904882708371567359223121716537613346809576985195159957903101732190271799133887608065288715909613599780494371497576802222612907925480033650082232356670934305872355142844742156499283138
def main1():
    pbar = tqdm(desc="Processing", unit="item", ncols=100, mininterval=0.3)
    pbar.n = 0

    s = math.isqrt(n)
    s0 = s

    while True:
        try:
            s += 1
            t = s*s - n
            print(t)
            if t == pow(math.isqrt(t), 2):
                print(f's:{s}\nt:{t}')
                break
            
            pbar.update(1)
        except KeyboardInterrupt:
            print(f'\ntimes:{s-s0}')
            break

    pbar.close()
    input()


def main2():
    x=6875959614719539964578044856324788659773927888725811990221440480403041297565413673276442869556256309834618150804618223293931971460218209133798855064585168
    y=3721
    z=math.isqrt(y)
    print(f'p={x+z}')
    print(f'q={x-z}')
    p=6875959614719539964578044856324788659773927888725811990221440480403041297565413673276442869556256309834618150804618223293931971460218209133798855064585229
    q=6875959614719539964578044856324788659773927888725811990221440480403041297565413673276442869556256309834618150804618223293931971460218209133798855064585107
    e=65537
    d = inverse(e, (p-1)*(q-1))
    m = pow(c,d,n)
    print(long_to_bytes(m))
    
if __name__=='__main__':
    main2()

```

### 出题思路

考察对自己计算机算力和计算方式得出答案速度的计算，这也是RSA一种非常简单的素数选取不当产生的漏洞。