## 真随机

### 题目描述

这回是真随机了，你还能从这随机的内容中解出flag嘛。

### 解题思路

发现flag被简单二分，上半是与随机byte进行与操作，下半是与随机byte进行或操作。

那我们知道：0与任意bit与还是0；1与任意bit或还是1。

那么，我们多次随机，其中上半每次都是0的时候就是0，否则为1；下半完全相反就行。

计算一下概率：用上半举例，对于每个bit位，共计算a次，是0却被错误当成1的可能性为0；是1却被错误当成0的可能性为`1/(2^a)`。那么对于本题300bits左右的题目来说，出错的概率大概`1-{1-1/[2^(a+1)]}^300`，我测试一百次这个概率可就太小啦，用`IEEE 754`会直接报0。

```python
from pwn import *
from tqdm import trange

# 设置服务器地址和端口
host = '111.111.111.111'  # 根据实际修改
port = 114514         # 根据实际修改

# 连接服务器
conn = remote(host, port)

# 收集样本数量，100次通常足够
samples = 100

# 初始化变量
first = True
l_front = 0
l_back = 0
front_bits = None
back_bits = None

# conn.interactive()

for i in trange(samples):
    line_a = conn.recvuntil(b'a = ')
    line_a = conn.recvline().strip().decode()
    print(line_a)
    
    # 接收"o ="行
    line_o = conn.recvuntil(b'o = ')
    line_o = conn.recvline().strip().decode()
    print(line_a)

    # 解析十六进制字符串
    a_hex = line_a.strip()
    o_hex = line_o.strip()

    if first:
        # 计算前半部分和后半部分的字节长度
        l_front = len(a_hex) // 2
        l_back = len(o_hex) // 2
        # 初始化位数组：前半部分初始为False，后半部分初始为True
        front_bits = [False] * (l_front * 8)
        back_bits = [True] * (l_back * 8)
        first = False

    # 将十六进制字符串转换为字节
    a_bytes = bytes.fromhex(a_hex)
    o_bytes = bytes.fromhex(o_hex)

    # 处理前半部分：按位与结果
    for byte_index, byte in enumerate(a_bytes):
        for bit_index in range(8):
            pos = byte_index * 8 + bit_index
            bit = (byte >> bit_index) & 1
            if bit == 1:
                front_bits[pos] = True

    # 处理后半部分：按位或结果
    for byte_index, byte in enumerate(o_bytes):
        for bit_index in range(8):
            pos = byte_index * 8 + bit_index
            bit = (byte >> bit_index) & 1
            if bit == 0:
                back_bits[pos] = False

    # 发送空行以触发下一次查询
    conn.sendline(b'1')

# 将前半部分的位转换为字节
front_bytes = []
for i in range(0, len(front_bits), 8):
    byte_bits = front_bits[i:i+8]
    byte = 0
    for j, bit in enumerate(byte_bits):
        if bit:
            byte |= (1 << j)
    front_bytes.append(byte)

# 将后半部分的位转换为字节
back_bytes = []
for i in range(0, len(back_bits), 8):
    byte_bits = back_bits[i:i+8]
    byte = 0
    for j, bit in enumerate(byte_bits):
        if bit:
            byte |= (1 << j)
    back_bytes.append(byte)

# 组合flag字节并输出
flag_bytes = bytes(front_bytes + back_bytes)
print(flag_bytes.decode())

conn.interactive()
```



### 出题思路

这么简单的题目，ai梭了看看脚本应该能理解吧，怎么这么少人做出来？

就是依旧是让大家熟悉bit上的操作，同时引入了密码学中比较重要的内容：概率。

很多算法其实都不是绝对的，只是会有一个类似成功率99.997%的概率。

这题也是，你万一运气不好还真有可能在收集了100甚至1000的情况下还有未恢复的bit，不过那我只能说你运气真好了，几乎相当于连买十次大乐透都中了头奖。。。